# Execution begins at address 0 
	.pos 0
	irmovq stack, %rsp
	call main
	halt

# Array of 9 elements
	.align 8
array:  .quad 0x0800000000000000
    .quad 0x0300000000000000
    .quad 0x0900000000000000
    .quad 0x0700000000000000
    .quad 0x0400000000000000
    .quad 0x0200000000000000
    .quad 0x0100000000000000
    .quad 0x0600000000000000
    .quad 0x0500000000000000

main:   irmovq array,%rdi
    irmovq $9,%rsi
    call bubble_a    # bubble_a(array, 9)
    ret

# void bubble_a(long *data, long count)
# data in %rdi, count in %rsi
bubble_a:   irmovq $1, %rax
    irmovq $8, %rcx
    subq %rax, %rsi        # last = count - 1
    jmp test_outer
loop_outer: rrmovq %rdi, %r8       # &data[i]
    xorq %rdx, %rdx        # i = 0
    jmp test_inner
loop_inner: rrmovq %r8, %r9 
    addq %rcx, %r9         
    mrmovq (%r8), %r10    # data[i]
    mrmovq (%r9), %r11    # data[i+1]
    subq %r11, %r10       # if (data[i+1] < data[i])
    jle test_inner
    mrmovq (%r8), %r10    # data[i]
    rmmovq %r10, (%r9)    # data[i+1] = data[i]
    rmmovq %r11, (%r8)    # data[i] = data[i+1]
    addq %rax, %rdx       # i++
    addq %rcx, %r8        # get addr of next element
test_inner: rrmovq %rsi, %r9      
    subq %rdx, %r9               
    jg loop_inner         
    subq %rax, %rsi       # last--
test_outer: jg loop_outer
    ret

# Stack starts here and grows to lower addresses
	.pos 0x200
stack:
